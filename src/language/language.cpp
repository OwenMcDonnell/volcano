/* Copyright (c) 2017 the Volcano Authors. Licensed under the GPLv3.
 *
 * This is Instance::ctorError(), though it is broken into a few different
 * methods.
 */
#include "language.h"
#include "VkEnum.h"
#include "VkInit.h"
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/vulkansamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>

namespace language {
using namespace VkEnum;

namespace {  // an anonymous namespace hides its contents outside this file

int explainCreateInstanceFail(VkResult v) {
  if (v != VK_SUCCESS) {
    logE("%s failed: %d (%s)\n", "vkCreateInstance", v, string_VkResult(v));
    if (v == VK_ERROR_INCOMPATIBLE_DRIVER) {
      logE("Most likely cause: your GPU does not support Vulkan yet.\n");
      logE("You may try updating your graphics driver.\n");
    } else if (v == VK_ERROR_OUT_OF_HOST_MEMORY) {
      logE(
          "Primary cause: you *might* be out of memory (unlikely).\n"
          "Secondary causes: conflicting vulkan drivers installed.\n"
          "Secondary causes: broken driver installation.\n"
          "You may want to search the web for more information.\n");
    }
    return 1;
  }
  return 0;
}

int initInstance(Instance& inst,
                 const std::vector<std::string>& enabledExtensions,
                 std::vector<VkLayerProperties>& availLayerProp) {
  std::set<std::string> avail;
  for (const auto& prop : availLayerProp) {
    auto r = avail.emplace(prop.layerName);
    if (!r.second) {
      logW("Instance::ctorError: VkLayerProperties \"%s\" is dup\n",
           prop.layerName);
    }
  }

  // Remove any inst.enabledLayers not in avail, and build a vector of char*
  std::vector<const char*> enabledLayersChar;
  for (auto i = inst.enabledLayers.begin(); i != inst.enabledLayers.end();) {
    if (!avail.count(*i)) {
      i = inst.enabledLayers.erase(i);
    } else {
      enabledLayersChar.push_back(i->c_str());
      i++;
    }
  }

  VkInstanceCreateInfo VkInit(iinfo);
  iinfo.pApplicationInfo = &inst.applicationInfo;
  std::vector<const char*> extPointers;
  if (enabledExtensions.size()) {
    iinfo.enabledExtensionCount = enabledExtensions.size();
    for (size_t i = 0; i < enabledExtensions.size(); i++) {
      extPointers.emplace_back(enabledExtensions.at(i).c_str());
    }
    iinfo.ppEnabledExtensionNames = extPointers.data();
  }
  iinfo.enabledLayerCount = enabledLayersChar.size();
  iinfo.ppEnabledLayerNames = enabledLayersChar.data();

  return explainCreateInstanceFail(
      vkCreateInstance(&iinfo, inst.pAllocator, &inst.vk));
}

}  // anonymous namespace

Instance::Instance() {
  applicationName = "TODO: " __FILE__ ": customize applicationName";
  engineName = "github.com/ndsol/volcano";

  VkOverwrite(applicationInfo);
  // Vulkan 1.1 is the highest API Volcano supports right now.
  applicationInfo.apiVersion = VK_MAKE_VERSION(1, 1, 0);
  applicationInfo.pApplicationName = applicationName.c_str();
  applicationInfo.applicationVersion = VK_MAKE_VERSION(0, 1, 0);
  applicationInfo.pEngineName = engineName.c_str();
}

int Instance::ctorError(CreateWindowSurfaceFn createWindowSurface,
                        void* window) {
  InstanceExtensionChooser instanceExtensions(*this);
  if (instanceExtensions.choose()) return 1;

  // Enable no layers. Just get a VkInstance to call vkEnumerateInstanceVersion
  VkPtr<VkInstance> earlyVk{vkDestroyInstance};
  VkInstanceCreateInfo VkInit(iinfo);
  VkApplicationInfo earlyAppInfo = applicationInfo;
  earlyAppInfo.apiVersion = VK_API_VERSION_1_0;
  iinfo.pApplicationInfo = &earlyAppInfo;
  VkResult v = vkCreateInstance(&iinfo, pAllocator, &earlyVk);
  if (explainCreateInstanceFail(v)) {
    return 1;
  }

  // Check what Vulkan API version is available.
  PFN_vkEnumerateInstanceVersion EnumerateInstanceVersion =
      (PFN_vkEnumerateInstanceVersion)vkGetInstanceProcAddr(
          earlyVk, "vkEnumerateInstanceVersion");
  if (!EnumerateInstanceVersion) {
    applicationInfo.apiVersion = VK_API_VERSION_1_0;
  } else {
    v = EnumerateInstanceVersion(&applicationInfo.apiVersion);
    if (v != VK_SUCCESS) {
      logE("vkEnumerateInstanceVersion failed: %d (%s). Falling back to 1.0.\n",
           v, string_VkResult(v));
      applicationInfo.apiVersion = VK_API_VERSION_1_0;
    }
  }
  // Vulkan 1.1 is the highest API Volcano supports right now.
  if (applicationInfo.apiVersion >= VK_MAKE_VERSION(1, 1, 0)) {
    applicationInfo.apiVersion = VK_MAKE_VERSION(1, 1, 0);
  }
  // Destroy the early VkInstance used to check the API version.
  earlyVk.reset();

  int r;
  {
    auto* layers = Vk::getLayers();
    if (layers == nullptr) return 1;

    r = initInstance(*this, instanceExtensions.chosen, *layers);
    delete layers;
    if (r) return r;
  }

  if ((r = initDebug()) != 0) return r;

  // surface.inst == VK_NULL_HANDLE, and needs to be reset to use vk.
  surface.reset(vk);
  if ((v = createWindowSurface(*this, window)) != VK_SUCCESS) {
    logE("%s failed: %d (%s)\n", "createWindowSurface (the user-provided fn)",
         v, string_VkResult(v));
    return 1;
  }
  surface.allocator = pAllocator;

  std::vector<VkPhysicalDevice>* physDevs = Vk::getDevices(vk);
  if (physDevs == nullptr) return 1;

  // Check all devices for lowest API version supported before creating any dev
  // If user-set minApiVersion is higher, use that.
  // minApiVersion of 0 will use the autodetected apiVersion.
  if (minApiVersion > 0 && minApiVersion < applicationInfo.apiVersion) {
    logE("Instance supports apiVersion %x, you set minApiVersion=%x.\n",
         applicationInfo.apiVersion, minApiVersion);
    logE("Driver does not support the requested minApiVersion.\n");
    return 1;
  }
  detectedApiVersionInUse = applicationInfo.apiVersion;
  for (const auto& phys : *physDevs) {
    // Just use Vulkan 1.0.x API to get apiVersion.
    VkPhysicalDeviceProperties VkInit(physProp);
    vkGetPhysicalDeviceProperties(phys, &physProp);
    if (physProp.apiVersion < detectedApiVersionInUse &&
        physProp.apiVersion >= minApiVersion) {
      detectedApiVersionInUse = physProp.apiVersion;
    }
  }

  uint32_t highestRejected = 0;
  for (const auto& phys : *physDevs) {
    // Construct a new dev.
    //
    // Be careful to also call pop_back() unless initSupportedQueues()
    // succeeded.
    devs.emplace_back(surface ? new Device{surface}
                              : new Device{VK_NULL_HANDLE});
    Device& dev = *devs.back();
    dev.inst = this;
    dev.phys = phys;
    if (dev.physProp.getProperties(dev)) {
      logE("Instance::ctorError: physProp.getProperties failed\n");
      delete physDevs;
      return 1;
    }
    if (dev.memProps.getProperties(dev)) {
      logE("Instance::ctorError: memProp.getProperties failed\n");
      delete physDevs;
      return 1;
    }

    VkResult r = initSupportedQueues(dev);
    switch (r) {
      case VK_SUCCESS:
        break;

      case VK_ERROR_DEVICE_LOST:
        devs.pop_back();
        break;

      case VK_INCOMPLETE:
        // This error will never be sent by a Vulkan API.
        // It just means minApiVersion blocked this device.
        if (highestRejected < dev.physProp.properties.apiVersion) {
          highestRejected = dev.physProp.properties.apiVersion;
        }
        devs.pop_back();
        break;

      default:
        devs.pop_back();
        delete physDevs;
        return 1;
    }
  }
  delete physDevs;

  if (devs.size() == 0) {
    logE("No Vulkan-capable devices found on your system.\n");
    if (highestRejected > 0) {
      logE("Volcano Instance.minApiVersion=%x > any device: %x supported\n",
           minApiVersion, highestRejected);
    } else {
      logE("Try running vulkaninfo to troubleshoot.\n");
    }
    return 1;
  }
  return r;
}

}  // namespace language
