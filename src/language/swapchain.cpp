/* Copyright (c) 2017 the Volcano Authors. Licensed under the GPLv3.
 */
#include "VkEnum.h"
#include "VkInit.h"
#include "language.h"
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/vulkansamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>

#include <algorithm>

namespace language {
using namespace VkEnum;

namespace {  // an anonymous namespace hides its contents outside this file

uint32_t calculateMinRequestedImages(const VkSurfaceCapabilitiesKHR& scap) {
  // An optimal number of images is one more than the minimum. For example:
  // double buffering minImageCount = 1. imageCount = 2.
  // triple buffering minImageCount = 2. imageCount = 3.
  uint32_t imageCount = scap.minImageCount + 1;

  // maxImageCount = 0 means "there is no maximum except device memory limits".
  if (scap.maxImageCount > 0 && imageCount > scap.maxImageCount) {
    imageCount = scap.maxImageCount;
  }

  // Note: The GPU driver can create more than the number returned here.
  // Device::images.size() gives the actual number created by the GPU driver.
  return imageCount;
}

VkExtent2D calculateSurfaceExtend2D(const VkSurfaceCapabilitiesKHR& scap,
                                    VkExtent2D sizeRequest) {
  // If currentExtent != { UINT32_MAX, UINT32_MAX } then Vulkan is telling us:
  // "this is the right extent: you already created a surface and Vulkan
  // computed the right size to match it."
  if (scap.currentExtent.width != std::numeric_limits<uint32_t>::max()) {
    return scap.currentExtent;
  }

  // Vulkan is telling us "choose width, height from scap.minImageExtent
  // to scap.maxImageExtent." Attempt to satisfy sizeRequest.
  const VkExtent2D &lo = scap.minImageExtent, hi = scap.maxImageExtent;
  return {
      /*width:*/ std::max(lo.width, std::min(hi.width, sizeRequest.width)),
      /*height:*/
      std::max(lo.height, std::min(hi.height, sizeRequest.height)),
  };
}

VkSurfaceTransformFlagBitsKHR calculateSurfaceTransform(
    const VkSurfaceCapabilitiesKHR& scap) {
  // Prefer no rotation (VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR).
  if (scap.supportedTransforms & VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR) {
    return VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR;
  }
  return scap.currentTransform;
}

}  // anonymous namespace

int Device::resetSwapChain() {
  VkSurfaceCapabilitiesKHR scap;
  VkResult v = vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
      phys, swapChainInfo.surface, &scap);
  if (v != VK_SUCCESS) {
    fprintf(stderr, "%s failed: %d (%s)\n",
            "vkGetPhysicalDeviceSurfaceCapabilitiesKHR", v, string_VkResult(v));
    return 1;
  }

  swapChainInfo.imageExtent =
      calculateSurfaceExtend2D(scap, swapChainInfo.imageExtent);

  VkSwapchainCreateInfoKHR scci = swapChainInfo;
  scci.minImageCount = calculateMinRequestedImages(scap);
  scci.preTransform = calculateSurfaceTransform(scap);
  scci.oldSwapchain = swapChain;
  uint32_t qfamIndices[] = {
      (uint32_t)getQfamI(PRESENT), (uint32_t)getQfamI(GRAPHICS),
  };
  if (qfamIndices[0] == qfamIndices[1]) {
    // Device queues were set up such that one QueueFamily does both
    // PRESENT and GRAPHICS.
    scci.imageSharingMode = VK_SHARING_MODE_EXCLUSIVE;
    scci.queueFamilyIndexCount = 0;
    scci.pQueueFamilyIndices = nullptr;
  } else {
    // Device queues were set up such that a different QueueFamily does PRESENT
    // and a different QueueFamily does GRAPHICS.
    scci.imageSharingMode = VK_SHARING_MODE_CONCURRENT;
    scci.queueFamilyIndexCount = 2;
    scci.pQueueFamilyIndices = qfamIndices;
  }
  VkSwapchainKHR newSwapChain;
  v = vkCreateSwapchainKHR(dev, &scci, dev.allocator, &newSwapChain);
  if (v != VK_SUCCESS) {
    fprintf(stderr, "%s failed: %d (%s)\n", "vkCreateSwapchainKHR", v,
            string_VkResult(v));
    return 1;
  }
  // This avoids deleting dev.swapChain until after vkCreateSwapchainKHR().
  swapChain.reset();             // Delete the old dev.swapChain.
  *(&swapChain) = newSwapChain;  // Install the new dev.swapChain.
  swapChain.allocator = dev.allocator;

  auto* vkImages = Vk::getSwapchainImages(dev, swapChain);
  if (!vkImages) {
    return 1;
  }

  framebufs.clear();
  for (size_t i = 0; i < vkImages->size(); i++) {
    framebufs.emplace_back(*this);
    auto& framebuf = framebufs.back();
    framebuf.image = vkImages->at(i);
    if (framebuf.imageView0.ctorError(*this, framebuf.image,
                                      scci.imageFormat)) {
      delete vkImages;
      return 1;
    }
    framebuf.attachments.emplace_back(framebuf.imageView0.vk);
  }
  delete vkImages;
  return 0;
}

}  // namespace language
