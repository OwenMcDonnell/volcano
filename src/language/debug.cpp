/* Copyright (c) 2017 the Volcano Authors. Licensed under the GPLv3.
 */
#include "VkInit.h"
#include "language.h"
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/vulkansamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>

namespace language {

namespace {  // use an anonymous namespace to hide all its contents (only
             // reachable from this file)

VKAPI_ATTR VkBool32 VKAPI_CALL debugReportCallback(
    VkFlags msgFlags, VkDebugReportObjectTypeEXT objType, uint64_t srcObject,
    size_t location, int32_t msgCode, const char* pLayerPrefix,
    const char* pMsg, void* pUserData) {
  (void)objType;
  (void)srcObject;
  (void)location;
  (void)pUserData;

#if !defined(_MSC_VER) && !defined(__ANDROID__)
  // Suppress the most common log messages.
  if (!strcmp(pLayerPrefix, "DebugReport")) {
    if (strstr(pMsg, "Added callback")) {
      return false;
    }
  } else if (!strcmp(pLayerPrefix, "Loader Message")) {
    /**
     * To view loader messages that are produced before Instance::initDebug(),
     * set VK_LOADER_DEBUG=all or VK_LOADER_DEBUG=error,warn,debug,...,info
     * (see g_loader_log_msgs in loader/loader.c)
     */
    if (!strncmp(pMsg, "Loading layer library", 21)) {
      return false;
    }
    if (!strncmp(pMsg, "Device Extension: ", 18)) {
      return false;
    }
  } else if (!strcmp(pLayerPrefix, "Validation")) {
    if (msgFlags &
        (VK_DEBUG_REPORT_DEBUG_BIT_EXT | VK_DEBUG_REPORT_INFORMATION_BIT_EXT)) {
      // Suppress messages like:
      // I Validation: code0: Object: 0x2 | OBJ[0x6] : CREATE CommandPool
      // object 0x2 I ObjectTracker: code0: Object: 0x2 | OBJ_STAT Destroy
      // CommandPool obj 0x2 ...
      return false;
    }
  }
#endif /* Suppress the most common log messages. */

  if (msgFlags & VK_DEBUG_REPORT_DEBUG_BIT_EXT) {
    logD("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_INFORMATION_BIT_EXT) {
    logI("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT) {
    logI("PerfWarn: %s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_WARNING_BIT_EXT) {
    logW("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_ERROR_BIT_EXT) {
    logE("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  }
  /*
   * Vulkan 1.0.64 spec clarifies that this should always return false.
   */
  return false;
}

}  // anonymous namespace

int Instance::initDebug() {
  //
  // There is this clever trick in the vulkaninfo source code:
  // iinfo.pNext = &dinfo;
  //
  // That is  amazing use of pNext. But it triggers a memory leak in
  // loader/loader.c: loader_instance_heap_free()
  // The OBJTRACK layer prints this out right before the double free():
  // "OBJ_STAT Destroy VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT obj 0x775d790 "
  // " (1 total objs remain & 0 VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT objs)"
  //
  // So manually call vkCreateDebugReportCallbackEXT() instead of using pNext.

  VkDebugReportCallbackCreateInfoEXT VkInit(dinfo);
  dinfo.flags =
      VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT |
      VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |
      VK_DEBUG_REPORT_INFORMATION_BIT_EXT | VK_DEBUG_REPORT_DEBUG_BIT_EXT;
  dinfo.pfnCallback = debugReportCallback;

  auto pCreateDebugReportCallback =
      (PFN_vkCreateDebugReportCallbackEXT)vkGetInstanceProcAddr(
          this->vk, "vkCreateDebugReportCallbackEXT");
  if (!pCreateDebugReportCallback) {
    logE("Failed to dlsym(vkCreateDebugReportCallbackEXT)\n");
    return 1;
  }

  this->pDestroyDebugReportCallbackEXT =
      (PFN_vkDestroyDebugReportCallbackEXT)vkGetInstanceProcAddr(
          this->vk, "vkDestroyDebugReportCallbackEXT");
  if (!this->pDestroyDebugReportCallbackEXT) {
    logE("Failed to dlsym(vkDestroyDebugReportCallbackEXT)\n");
    return 1;
  }

  VkResult v = pCreateDebugReportCallback(this->vk, &dinfo, pAllocator,
                                          &this->debugReport);
  if (v != VK_SUCCESS) {
    logE("%s failed: %d (%s)\n", "pCreateDebugReportCallback", v,
         string_VkResult(v));
    return 1;
  }
  return 0;
}

Instance::~Instance() {
  if (pDestroyDebugReportCallbackEXT) {
    pDestroyDebugReportCallbackEXT(vk, debugReport, pAllocator);
  }
}

uint32_t Device::apiVersionInUse() const { return inst->apiVersionInUse(); }

void Device::apiUsage(int v1, int v2, int v3, bool pred, const char* fmt, ...) {
  uint32_t v = apiVersionInUse();
  if (VK_MAKE_VERSION(uint32_t(v1), uint32_t(v2), uint32_t(v3)) <= v || !pred) {
    return;
  }

  logW("Vulkan %u.%u.%u found, but %d.%d.%d wanted for\n", VK_VERSION_MAJOR(v),
       VK_VERSION_MINOR(v), VK_VERSION_PATCH(v), v1, v2, v3);
  va_list ap;
  va_start(ap, fmt);
  logVolcano('W', fmt, ap);
  va_end(ap);
}

void Device::extensionUsage(const char* name, bool pred, const char* fmt, ...) {
  for (auto req : requiredExtensions) {
    if (!strcmp(name, req)) {
      return;
    }
  }
  for (auto req : inst->requiredExtensions) {
    if (req == name) {
      return;
    }
  }
  if (!pred) {
    return;
  }

  logW("Extension \"%s\" needed for\n", name);
  va_list ap;
  va_start(ap, fmt);
  logVolcano('W', fmt, ap);
  va_end(ap);
}

}  // namespace language
