/* Copyright (c) 2017 the Volcano Authors. Licensed under the GPLv3.
 */
#include "VkInit.h"
#include "language.h"
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/vulkansamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>

namespace language {

namespace {  // use an anonymous namespace to hide all its contents (only
             // reachable from this file)

VKAPI_ATTR VkBool32 VKAPI_CALL debugReportCallback(
    VkFlags msgFlags, VkDebugReportObjectTypeEXT objType, uint64_t srcObject,
    size_t location, int32_t msgCode, const char* pLayerPrefix,
    const char* pMsg, void* pUserData) {
  (void)objType;
  (void)srcObject;
  (void)location;
  (void)pUserData;

#if !defined(_MSC_VER) && !defined(__ANDROID__)
  // Suppress the most common log messages.
  static uint64_t debugLineCount = 0;
  static uint32_t suppressState = 0;
  debugLineCount++;

  if (!strcmp(pLayerPrefix, "DebugReport")) {
    if (!strcmp(pMsg, "Added callback")) {
      return false;
    }
  } else if (!strcmp(pLayerPrefix, "loader")) {
    /**
     * To view loader messages that are produced before Instance::initDebug(),
     * set VK_LOADER_DEBUG=all or VK_LOADER_DEBUG=error,warn,debug,...,info
     * (see g_loader_log_msgs in loader/loader.c)
     */
    if (strstr(pMsg, "manifest file") && debugLineCount < 20) {
      return false;
    }
    if (strstr(pMsg, VK_LAYER_LUNARG_standard_validation) &&
        debugLineCount < 30) {
      return false;
    }
    if (!strcmp(pMsg, "Build ICD instance extension list")) {
      suppressState = 1;
      return false;
    }
    if (suppressState == 1 && !strncmp(pMsg, "Instance Extension:", 19)) {
      return false;
    }
    if (!strncmp(pMsg, "Searching for ICD drivers named", 31)) {
      return false;
    }
    if (!strncmp(pMsg, "Chain: instance: Loading layer library", 38)) {
      return false;
    }
    if (!strncmp(pMsg, "Device Extension: ", 18)) {
      return false;
    }
    suppressState = 0;
  } else if (!strcmp(pLayerPrefix, "ObjectTracker")) {
    if (msgFlags &
        (VK_DEBUG_REPORT_DEBUG_BIT_EXT | VK_DEBUG_REPORT_INFORMATION_BIT_EXT)) {
      return false;
    }
  } else if (!strcmp(pLayerPrefix, "MEM")) {
    if (strstr(pMsg, "Details of") && msgCode == 0) {
      suppressState = 2;
      return false;
    }
    if (!strcmp(pMsg, "=============================") || suppressState == 2) {
      return false;
    }
  } else if (!strcmp(pLayerPrefix, "DS")) {
    if ((msgFlags & VK_DEBUG_REPORT_DEBUG_BIT_EXT) &&
        !strncmp(pMsg, "vkCmdDraw()", 11)) {
      suppressState = 3;
      return false;
    }
    if (suppressState == 3 &&
        (msgFlags & (VK_DEBUG_REPORT_DEBUG_BIT_EXT |
                     VK_DEBUG_REPORT_INFORMATION_BIT_EXT)) != 0) {
      return false;
    }
  }
  suppressState = 0;
#endif /* Suppress the most common log messages. */

  if (msgFlags & VK_DEBUG_REPORT_DEBUG_BIT_EXT) {
    logD("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_INFORMATION_BIT_EXT) {
    logI("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT) {
    logI("PerfWarn: %s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_WARNING_BIT_EXT) {
    logW("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  } else if (msgFlags & VK_DEBUG_REPORT_ERROR_BIT_EXT) {
    logE("%s: code%d: %s\n", pLayerPrefix, msgCode, pMsg);
  }
  /*
   * Vulkan 1.0.64 spec clarifies that this should always return false.
   */
  return false;
}

}  // anonymous namespace

int Instance::initDebug() {
  //
  // There is this clever trick in the vulkaninfo source code:
  // iinfo.pNext = &dinfo;
  //
  // That is  amazing use of pNext. But it triggers a memory leak in
  // loader/loader.c: loader_instance_heap_free()
  // The OBJTRACK layer prints this out right before the double free():
  // "OBJ_STAT Destroy VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT obj 0x775d790 "
  // " (1 total objs remain & 0 VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT objs)"
  //
  // So manually call vkCreateDebugReportCallbackEXT() instead of using pNext.

  VkDebugReportCallbackCreateInfoEXT VkInit(dinfo);
  dinfo.flags =
      VK_DEBUG_REPORT_ERROR_BIT_EXT | VK_DEBUG_REPORT_WARNING_BIT_EXT |
      VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT |
      VK_DEBUG_REPORT_INFORMATION_BIT_EXT | VK_DEBUG_REPORT_DEBUG_BIT_EXT;
  dinfo.pfnCallback = debugReportCallback;

  auto pCreateDebugReportCallback =
      (PFN_vkCreateDebugReportCallbackEXT)vkGetInstanceProcAddr(
          this->vk, "vkCreateDebugReportCallbackEXT");
  if (!pCreateDebugReportCallback) {
    logE("Failed to dlsym(vkCreateDebugReportCallbackEXT)\n");
    return 1;
  }

  this->pDestroyDebugReportCallbackEXT =
      (PFN_vkDestroyDebugReportCallbackEXT)vkGetInstanceProcAddr(
          this->vk, "vkDestroyDebugReportCallbackEXT");
  if (!this->pDestroyDebugReportCallbackEXT) {
    logE("Failed to dlsym(vkDestroyDebugReportCallbackEXT)\n");
    return 1;
  }

  VkResult v = pCreateDebugReportCallback(this->vk, &dinfo, pAllocator,
                                          &this->debugReport);
  if (v != VK_SUCCESS) {
    logE("%s failed: %d (%s)\n", "pCreateDebugReportCallback", v,
         string_VkResult(v));
    return 1;
  }
  return 0;
}

int dbg_lvl = 0;

Instance::~Instance() {
  if (pDestroyDebugReportCallbackEXT) {
    pDestroyDebugReportCallbackEXT(vk, debugReport, pAllocator);
  }
}

}  // namespace language
