/* Copyright (c) 2017 the Volcano Authors. Licensed under the GPLv3.
 */
#include "VkEnum.h"
#include "VkInit.h"
#include "language.h"
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/vulkansamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>

namespace language {
using namespace VkEnum;

VkResult Instance::initSupportedQueues(
    Device& dev, std::vector<VkQueueFamilyProperties>& vkQFams) {
  VkPhysicalDeviceFeatures VkInit(physDevFeatures);
  vkGetPhysicalDeviceFeatures(dev.phys, &physDevFeatures);

// Check Instance::features and enable if physDevFeatures supports it also.
#define ENABLE_IF_SUPPORTED(x) \
  dev.enabledFeatures.x = (features.x) && (physDevFeatures.x);
  ENABLE_IF_SUPPORTED(robustBufferAccess);
  ENABLE_IF_SUPPORTED(fullDrawIndexUint32);
  ENABLE_IF_SUPPORTED(imageCubeArray);
  ENABLE_IF_SUPPORTED(independentBlend);
  ENABLE_IF_SUPPORTED(geometryShader);
  ENABLE_IF_SUPPORTED(tessellationShader);
  ENABLE_IF_SUPPORTED(sampleRateShading);
  ENABLE_IF_SUPPORTED(dualSrcBlend);
  ENABLE_IF_SUPPORTED(logicOp);
  ENABLE_IF_SUPPORTED(multiDrawIndirect);
  ENABLE_IF_SUPPORTED(drawIndirectFirstInstance);
  ENABLE_IF_SUPPORTED(depthClamp);
  ENABLE_IF_SUPPORTED(depthBiasClamp);
  ENABLE_IF_SUPPORTED(fillModeNonSolid);
  ENABLE_IF_SUPPORTED(depthBounds);
  ENABLE_IF_SUPPORTED(wideLines);
  ENABLE_IF_SUPPORTED(largePoints);
  ENABLE_IF_SUPPORTED(alphaToOne);
  ENABLE_IF_SUPPORTED(multiViewport);
  ENABLE_IF_SUPPORTED(samplerAnisotropy);
  ENABLE_IF_SUPPORTED(textureCompressionETC2);
  ENABLE_IF_SUPPORTED(textureCompressionASTC_LDR);
  ENABLE_IF_SUPPORTED(textureCompressionBC);
  ENABLE_IF_SUPPORTED(occlusionQueryPrecise);
  ENABLE_IF_SUPPORTED(pipelineStatisticsQuery);
  ENABLE_IF_SUPPORTED(vertexPipelineStoresAndAtomics);
  ENABLE_IF_SUPPORTED(fragmentStoresAndAtomics);
  ENABLE_IF_SUPPORTED(shaderTessellationAndGeometryPointSize);
  ENABLE_IF_SUPPORTED(shaderImageGatherExtended);
  ENABLE_IF_SUPPORTED(shaderStorageImageExtendedFormats);
  ENABLE_IF_SUPPORTED(shaderStorageImageMultisample);
  ENABLE_IF_SUPPORTED(shaderStorageImageReadWithoutFormat);
  ENABLE_IF_SUPPORTED(shaderStorageImageWriteWithoutFormat);
  ENABLE_IF_SUPPORTED(shaderUniformBufferArrayDynamicIndexing);
  ENABLE_IF_SUPPORTED(shaderSampledImageArrayDynamicIndexing);
  ENABLE_IF_SUPPORTED(shaderStorageBufferArrayDynamicIndexing);
  ENABLE_IF_SUPPORTED(shaderStorageImageArrayDynamicIndexing);
  ENABLE_IF_SUPPORTED(shaderClipDistance);
  ENABLE_IF_SUPPORTED(shaderCullDistance);
  ENABLE_IF_SUPPORTED(shaderFloat64);
  ENABLE_IF_SUPPORTED(shaderInt64);
  ENABLE_IF_SUPPORTED(shaderInt16);
  ENABLE_IF_SUPPORTED(shaderResourceResidency);
  ENABLE_IF_SUPPORTED(shaderResourceMinLod);
  ENABLE_IF_SUPPORTED(sparseBinding);
  ENABLE_IF_SUPPORTED(sparseResidencyBuffer);
  ENABLE_IF_SUPPORTED(sparseResidencyImage2D);
  ENABLE_IF_SUPPORTED(sparseResidencyImage3D);
  ENABLE_IF_SUPPORTED(sparseResidency2Samples);
  ENABLE_IF_SUPPORTED(sparseResidency4Samples);
  ENABLE_IF_SUPPORTED(sparseResidency8Samples);
  ENABLE_IF_SUPPORTED(sparseResidency16Samples);
  ENABLE_IF_SUPPORTED(sparseResidencyAliased);
  ENABLE_IF_SUPPORTED(variableMultisampleRate);
  ENABLE_IF_SUPPORTED(inheritedQueries);
#undef ENABLE_IF_SUPPORTED

  VkBool32 oneQueueWithPresentSupported = false;
  for (size_t q_i = 0; q_i < vkQFams.size(); q_i++) {
    VkBool32 isPresentSupported = false;
    if (dev.swapChainInfo.surface) {
      // Probe VkPhysicalDevice for surface support.
      VkResult v = vkGetPhysicalDeviceSurfaceSupportKHR(
          dev.phys, q_i, dev.swapChainInfo.surface, &isPresentSupported);
      if (v != VK_SUCCESS) {
        logE("qfam %zu: %s failed: %d (%s)\n", q_i,
             "vkGetPhysicalDeviceSurfaceSupportKHR", v, string_VkResult(v));
        return VK_ERROR_INITIALIZATION_FAILED;
      }
      oneQueueWithPresentSupported |= isPresentSupported;
    }

    dev.qfams.emplace_back(vkQFams.at(q_i),
                           isPresentSupported ? PRESENT : NONE);
  }

  auto* devExtensions = Vk::getDeviceExtensions(dev.phys);
  if (!devExtensions) {
    return VK_ERROR_INITIALIZATION_FAILED;
  }
  dev.availableExtensions = *devExtensions;
  delete devExtensions;
  devExtensions = nullptr;

  if (!oneQueueWithPresentSupported) {
    return VK_SUCCESS;
  }

  // A device with a queue with PRESENT support should have all of
  // deviceWithPresentRequiredExts.
  static const char* deviceWithPresentRequiredExts[] = {
      VK_KHR_SWAPCHAIN_EXTENSION_NAME,
  };

  size_t i = 0, j;
  for (; i < sizeof(deviceWithPresentRequiredExts) /
                 sizeof(deviceWithPresentRequiredExts[0]);
       i++) {
    for (j = 0; j < dev.availableExtensions.size(); j++) {
      if (!strcmp(dev.availableExtensions.at(j).extensionName,
                  deviceWithPresentRequiredExts[i])) {
        dev.extensionRequests.push_back(deviceWithPresentRequiredExts[i]);
        break;
      }
    }
    if (j >= dev.availableExtensions.size()) {
      // Do not add dev: it claims oneQueueWithPresentSupported but it lacks
      // required extensions. (If it does not do PRESENT at all, it is
      // assumed the device would not be used in the swap chain anyway, so it
      // is not removed.)
      return VK_ERROR_DEVICE_LOST;
    }
  }

  // Init dev.surfaceFormats and dev.presentModes early. Your app can inspect
  // and modify them and then call open().
  int r = dev.initSurfaceFormatAndPresentMode();
  if (r) {
    return VK_ERROR_INITIALIZATION_FAILED;
  }
  if (dev.surfaceFormats.size() == 0 || dev.presentModes.size() == 0) {
    // Do not add dev: it claims oneQueueWithPresentSupported but it has no
    // surfaceFormats -- or no presentModes.
    return VK_ERROR_DEVICE_LOST;
  }
  return VK_SUCCESS;
}

}  // namespace language
