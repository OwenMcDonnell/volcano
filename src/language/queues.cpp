/* Copyright (c) 2017 the Volcano Authors. Licensed under the GPLv3.
 *
 * This is Instance::open(), though it is broken into a few different methods.
 */
#include "VkEnum.h"
#include "VkInit.h"
#include "language.h"
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/vulkansamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>

#include <map>

namespace language {
using namespace VkEnum;

int Instance::initQueues(std::vector<QueueRequest>& request) {
  // Search for a single device that support minSurfaceSupport.
  bool foundQueue = false;
  for (size_t dev_i = 0; dev_i < devs.size(); dev_i++) {
    auto selectedQfams = requestQfams(dev_i, minSurfaceSupport);
    foundQueue |= selectedQfams.size() > 0;
    request.insert(request.end(), selectedQfams.begin(), selectedQfams.end());
  }
  if (!foundQueue) {
    logE("Error: no device has minSurfaceSupport.\n");
    return 1;
  }
  return 0;
}

int Instance::open(VkExtent2D surfaceSizeRequest) {
  std::vector<QueueRequest> request;
  int r = initQueues(request);
  if (r != 0) {
    return r;
  }

  // Split up QueueRequest by device index. This has the side effect of
  // ignoring any device for which there is no QueueRequest.
  std::map<uint32_t, std::vector<QueueRequest>> requested_devs;
  for (auto& req : request) {
    auto it = requested_devs.find(req.dev_index);
    if (it == requested_devs.end()) {
      auto ret =
          requested_devs.emplace(req.dev_index, std::vector<QueueRequest>());
      it = ret.first;
    }
    it->second.push_back(req);
  }

  // For each device that has one or more queues requested, call
  // vkCreateDevice() i.e. dispatch each queue request's dev_index to
  // vkCreateDevice()
  for (const auto& kv : requested_devs) {
    auto& dev = *devs.at(kv.first);
    std::vector<VkDeviceQueueCreateInfo> allQci;

    // Vulkan wants the queues grouped by queue family (and also grouped by
    // device). kv.second (a vector<QueueRequest>) has an unordered list of
    // dev_qfam_index. Assemble QueueRequests by brute force looking for each
    // dev_qfam_index.
    for (size_t q_i = 0; q_i < dev.qfams.size(); q_i++) {
      auto& qfam = dev.qfams.at(q_i);
      for (const auto& qr : kv.second) {
        if (qr.dev_qfam_index == q_i) {
          // prios vector size() is the number of requests for this qfam
          qfam.prios.push_back(qr.priority);
        }
      }

      if (qfam.prios.size() < 1) {
        continue;  // This qfam is not being requested on this dev.
      } else if (qfam.prios.size() > qfam.vk.queueCount) {
        fprintf(
            stderr,
            "Cannot request %zu of dev_i=%zu, qFam[%zu] (max %zu allowed)\n",
            qfam.prios.size(), (size_t)kv.first, q_i,
            (size_t)qfam.vk.queueCount);
        return 1;
      }

      VkDeviceQueueCreateInfo VkInit(dqci);
      dqci.queueFamilyIndex = q_i;
      dqci.queueCount = qfam.prios.size();
      dqci.pQueuePriorities = qfam.prios.data();
      allQci.push_back(dqci);
    }

    // Enable device layer "VK_LAYER_LUNARG_standard_validation"
    std::vector<const char*> enabledLayers;
    enabledLayers.push_back(VK_LAYER_LUNARG_standard_validation);

    VkDeviceCreateInfo VkInit(dCreateInfo);
    dCreateInfo.queueCreateInfoCount = allQci.size();
    dCreateInfo.pQueueCreateInfos = allQci.data();
    dCreateInfo.pEnabledFeatures = &dev.enabledFeatures;
    if (dev.extensionRequests.size()) {
      dCreateInfo.enabledExtensionCount = dev.extensionRequests.size();
      dCreateInfo.ppEnabledExtensionNames = dev.extensionRequests.data();
    }
    dCreateInfo.enabledLayerCount = enabledLayers.size();
    dCreateInfo.ppEnabledLayerNames = enabledLayers.data();

    VkResult v = vkCreateDevice(dev.phys, &dCreateInfo, pAllocator, &dev.dev);
    if (v != VK_SUCCESS) {
      logE("dev_i=%zu %s failed: %d (%s)\n", (size_t)kv.first, "VkCreateDevice",
           v, string_VkResult(v));
      return 1;
    }
    dev.dev.allocator = pAllocator;
    dev.swapChainInfo.imageExtent = surfaceSizeRequest;
  }

  size_t swap_chain_count = 0;
  for (const auto& kv : requested_devs) {
    auto& dev = *devs.at(kv.first);
    size_t q_count = 0;
    for (size_t q_i = 0; q_i < dev.qfams.size(); q_i++) {
      auto& qfam = dev.qfams.at(q_i);
      if (dbg_lvl && qfam.prios.size()) {
        logD("dev_i=%u q_count=%zu adding qfam[%zu] x %zu\n", kv.first, q_count,
             q_i, qfam.prios.size());
      }
      // Copy the newly minted VkQueue objects into dev.qfam.queues.
      for (size_t i = 0; i < qfam.prios.size(); i++) {
        qfam.queues.emplace_back();
        vkGetDeviceQueue(dev.dev, q_i, i, &(*(qfam.queues.end() - 1)));
        q_count++;
      }
    }
    if (!q_count) {
      dev.presentModes.clear();
    } else if (dev.presentModes.size()) {
      if (swap_chain_count == 1) {
        logW("Warn: A multi-GPU setup probably does not work.\n");
        logW("Warn: Here be dragons.\n");
        logW("https://lunarg.com/faqs/vulkan-multiple-gpus-acceleration/\n");
      }
      swap_chain_count++;
    }
  }
  return 0;
}

}  // namespace language
