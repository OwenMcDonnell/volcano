/* Copyright (c) 2017 the Volcano Authors. Licensed under the GPLv3.
 *
 * This is Instance::open(), though it is broken into a few different methods.
 */
#include "VkEnum.h"
#include "VkInit.h"
#include "language.h"
// vk_enum_string_helper.h is not in the default vulkan installation, but is
// generated by the gn/vendor/vulkansamples/BUILD.gn file in this repo.
#include <vulkan/vk_enum_string_helper.h>

#include <map>

namespace language {
using namespace VkEnum;

int Instance::initQueues(std::vector<QueueRequest>& request) {
  // Search for a single device that support minSurfaceSupport.
  bool foundQueue = false;
  for (size_t dev_i = 0; dev_i < devs.size(); dev_i++) {
    auto selectedQfams = requestQfams(dev_i, minSurfaceSupport);
    foundQueue |= selectedQfams.size() > 0;
    request.insert(request.end(), selectedQfams.begin(), selectedQfams.end());
  }
  if (!foundQueue) {
    logE("Error: no device has minSurfaceSupport.\n");
    return 1;
  }
  return 0;
}

int Instance::open(VkExtent2D surfaceSizeRequest) {
  std::vector<QueueRequest> request;
  int r = initQueues(request);
  if (r != 0) {
    return r;
  }

  // Split up QueueRequest by device index. This has the side effect of
  // ignoring any device for which there is no QueueRequest.
  std::map<uint32_t, std::vector<QueueRequest>> requested_devs;
  for (auto& req : request) {
    auto it = requested_devs.find(req.dev_index);
    if (it == requested_devs.end()) {
      auto ret =
          requested_devs.emplace(req.dev_index, std::vector<QueueRequest>());
      it = ret.first;
    }
    it->second.push_back(req);
  }

  // For each device that has one or more queues requested, call vkCreateDevice
  // i.e. dispatch each queue request's dev_index to vkCreateDevice now.
  for (const auto& kv : requested_devs) {
    auto& dev = *devs.at(kv.first);
    std::vector<VkDeviceQueueCreateInfo> allQci;

    // Vulkan wants the queues grouped by queue family (and also grouped by
    // device). kv.second (a vector<QueueRequest>) has an unordered list of
    // dev_qfam_index. Assemble QueueRequests by brute force looking for each
    // dev_qfam_index.
    for (size_t q_i = 0; q_i < dev.qfams.size(); q_i++) {
      auto& qfam = dev.qfams.at(q_i);
      for (const auto& qr : kv.second) {
        if (qr.dev_qfam_index == q_i) {
          // prios vector size() is the number of requests for this qfam
          qfam.prios.push_back(qr.priority);
        }
      }

      if (qfam.prios.size() < 1) {
        continue;  // This qfam is not being requested on this dev.
      } else if (qfam.prios.size() > qfam.queueFamilyProperties.queueCount) {
        logE("Cannot request %zu of dev_i=%zu, qFam[%zu] (max %zu allowed)\n",
             qfam.prios.size(), (size_t)kv.first, q_i,
             (size_t)qfam.queueFamilyProperties.queueCount);
        return 1;
      }

      VkDeviceQueueCreateInfo VkInit(dqci);
      dqci.queueFamilyIndex = q_i;
      dqci.queueCount = qfam.prios.size();
      dqci.pQueuePriorities = qfam.prios.data();
      allQci.push_back(dqci);
    }

    // Check dev.enableFeatures against dev.availableFeatures.
    for (const auto kv : dev.enabledFeatures.reflect) {
      const auto& name = kv.first.c_str();
      VkBool32 enabled, avail;
      if (dev.enabledFeatures.get(name, enabled) ||
          dev.availableFeatures.get(name, avail)) {
        return 1;
      }
      if (enabled && !avail && dev.enabledFeatures.set(name, VK_FALSE)) {
        logE("enabledFeatures.set(%s, false) failed\n", name);
        return 1;
      }
    }

    VkDeviceCreateInfo VkInit(dCreateInfo);
    dCreateInfo.queueCreateInfoCount = allQci.size();
    dCreateInfo.pQueueCreateInfos = allQci.data();
    if (apiVersionInUse() < VK_MAKE_VERSION(1, 1, 0)) {
      dCreateInfo.pEnabledFeatures = &dev.enabledFeatures.features;
    } else {
      dCreateInfo.pEnabledFeatures = NULL;
      dCreateInfo.pNext = &dev.enabledFeatures;
    }
    if (dev.requiredExtensions.size()) {
      dCreateInfo.enabledExtensionCount = dev.requiredExtensions.size();
      dCreateInfo.ppEnabledExtensionNames = dev.requiredExtensions.data();
    }
    // As of Vulkan 1.0.33, device-only layers are now deprecated.
    dCreateInfo.enabledLayerCount = 0;
    dCreateInfo.ppEnabledLayerNames = 0;

    VkResult v = vkCreateDevice(dev.phys, &dCreateInfo, pAllocator, &dev.dev);
    if (v != VK_SUCCESS) {
      logE("dev_i=%zu %s failed: %d (%s)\n", (size_t)kv.first, "vkCreateDevice",
           v, string_VkResult(v));
      return 1;
    }
    dev.dev.allocator = pAllocator;
    dev.swapChainInfo.imageExtent = surfaceSizeRequest;
  }

  size_t swap_chain_count = 0;
  for (const auto& kv : requested_devs) {
    auto& dev = *devs.at(kv.first);
    size_t q_count = 0;
    for (size_t q_i = 0; q_i < dev.qfams.size(); q_i++) {
      auto& qfam = dev.qfams.at(q_i);
      // Copy the newly minted VkQueue objects into dev.qfam.queues.
      for (size_t i = 0; i < qfam.prios.size(); i++) {
        qfam.queues.emplace_back();
        vkGetDeviceQueue(dev.dev, q_i, i, &(*(qfam.queues.end() - 1)));
        q_count++;
      }
    }
    if (!q_count) {
      dev.presentModes.clear();
    } else if (dev.presentModes.size()) {
      if (swap_chain_count == 1) {
        logW("Warn: A multi-GPU setup probably does not work.\n");
        logW("Warn: Here be dragons.\n");
        logW("https://lunarg.com/faqs/vulkan-multiple-gpus-acceleration/\n");
      }
      swap_chain_count++;
    }
  }
  return 0;
}

}  // namespace language
